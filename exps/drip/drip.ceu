class DS_drip with
    var u16 key;
    var u8  len;
    var DS_trickle trickle;
    event void go;
    event s8*  go_change;
    event s8*  ok_changed;
do
    event void send_data;
    var u32 seqno = 0;
    await/0 go;
    var _message_t msg;
        _Radio_setSource(&msg, _TOS_NODE_ID);
        _Radio_setDestination(&msg, _AM_BROADCAST_ADDR);
    var _dissemination_message_t* pay;
    finalize
        pay = _Radio_getPayload(&msg, sizeof<_dissemination_message_t>);
    with
        nothing;    // msg_meta/pay_meta have the same scope
    end
    pay:key = this.key;
    par do
        loop do
            par/or do
                await trickle.ok_fired;
                pay:seqno = seqno;
                _Radio_setType(&msg, _DISSEMINATION_PROTO);
                _Radio_setPayloadLength(&msg, sizeof<_dissemination_message_t>);
            with
                await send_data;
                pay:seqno = seqno;
                _Radio_setType(&msg, _DISSEMINATION_PROTO+1);
                _Radio_setPayloadLength(&msg, sizeof<_dissemination_message_t>+this.len);
            end
            emit RADIO_SEND(&msg);
            await RADIO_SENDDONE;
        end
    with
        loop do
            await go_change;
            _memcpy(pay:data, go_change, this.len);
            seqno = seqno >> 16;                        // increment seqno
            seqno = seqno + 1;
            if seqno == 0 then
                seqno = 1;
            end
            seqno = seqno << 16;
            seqno = seqno + _TOS_NODE_ID;
            emit trickle.go_reset;                      // reset trickle
            emit send_data;                             // broadcast new data
            emit this.ok_changed = pay:data;            // signal main app
        end
    with
        loop do
            var _message_t* msg = await RADIO_RECEIVE;
            var int tp = _Radio_getType(msg);
            var _dissemination_message_t* pay;
            finalize
                pay = _Radio_getPayload(msg, sizeof<_dissemination_message_t>+this.len);
            with
                nothing;    // msg/pay have the same scope
            end
            if (tp==_DISSEMINATION_PROTO or tp==_DISSEMINATION_PROTO+1) and
                pay and (pay:key==this.key) then
                if seqno == pay:seqno then
                    emit trickle.go_inc;        // same data: inc trickle
                else/if seqno > pay:seqno then
                    // TODO: poderia esperar tempo aleatorio e so mandar se nao 
                    // receber de um vizinho
                    emit send_data;             // old data: send mine
                else/if seqno < pay:seqno then
                    emit trickle.go_reset;      // new data: reset trickle
                    if tp == _DISSEMINATION_PROTO+1 then
                        seqno = pay:seqno;      // update my data
                        _memcpy(pay:data, pay:data, this.len);
                        emit this.ok_changed=pay:data;
                    end
                end
            end
        end
    end
end
